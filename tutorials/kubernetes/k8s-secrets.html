<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kubernetes - Kubernetes Secrets (secrets) | MTI TEK</title>
<meta name="description" content="Tutorials: Kubernetes - Kubernetes Secrets (secrets)" />
<meta name="author" content="mtitek.com" />
<meta name="robots" content="index, follow, noarchive, nocache" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Kubernetes - Kubernetes Secrets (secrets) | MTI TEK" />
<meta property="og:description" content="Tutorials: Kubernetes - Kubernetes Secrets (secrets)" />
<meta property="og:url" content="http://mtitek.com/tutorials/kubernetes/k8s-secrets.html" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Kubernetes - Kubernetes Secrets (secrets) | MTI TEK" />
<meta name="twitter:description" content="Tutorials: Kubernetes - Kubernetes Secrets (secrets)" />
<meta name="twitter:site" content="@mtitek" />
<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "mtitek.com",
        "url": "http://mtitek.com/tutorials/kubernetes/k8s-secrets.html",
        "description": "Tutorials: Kubernetes - Kubernetes Secrets (secrets)",
        "author": {
            "@type": "Person",
            "name": "MTI TEK"
        }
    }
</script>
<link rel="canonical" href="http://mtitek.com/tutorials/kubernetes/k8s-secrets.html" />
<link rel="icon" href="/favicon-mtitek.ico" type="image/x-icon">
<link rel="icon" href="/favicon-mtitek.svg" type="image/svg+xml">
<link rel="stylesheet" href="/bootstrap-5.3.3-dist/css/bootstrap.min.css" />
<link rel="stylesheet" href="/cdnjs/6.7.2/css/all.min.css" />
<link rel="stylesheet" href="/css/css-j/mtitek.style.global-min.css" />
<link rel="stylesheet" href="/css/css-j/mtitek.style.header-min.css" />
<link rel="stylesheet" href="/css/css-j/mtitek.style.tutorial.sections.css" />
<link rel="stylesheet" href="/css/css-j/mtitek.style.footer-min.css" />
<link rel="stylesheet" href="/css/css-j/mtitek.style.layout-min.css" />
<script src="/bootstrap-5.3.3-dist/js/bootstrap.bundle.min.js" defer></script>
<script src="/cdnjs/6.7.2/js/all.min.js" defer></script>
</head>
<body>
<div class="container">
<div class="menuHeaderDiv1">
<header class="modern-header">
<div class="container">
<div class="header-content">
<div class="logo-section">
<a href="/" class="logo">MTI TEK</a>
</div>
<nav class="main-nav">
<ul class="nav-list">
<li><a class="nav-link " href="/"><i class="fas fa-home"></i> Home</a></li>
<li><a class="nav-link " href="/tutorials/ml/llm/"><i class="fas fa-brain"></i> LLMs</a></li>
<li><a class="nav-link " href="/tutorials/docker/"><i class="fab fa-docker"></i> Docker</a></li>
<li><a class="nav-link active" href="/tutorials/kubernetes/"><i class="fas fa-dharmachakra"></i> Kubernetes</a></li>
<li><a class="nav-link " href="/tutorials/java/"><i class="fab fa-java"></i> Java</a></li>
<li><a class="nav-link " href="/all.html"><i class="fas fa-list"></i> All Resources</a></li>
</ul>
</nav>
<div class="mobile-menu-toggle">
<span></span>
<span></span>
<span></span>
</div>
</div>
</div>
</header>
</div>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const mobileToggle = document.querySelector('.mobile-menu-toggle');
    const mainNav = document.querySelector('.main-nav');

    if (mobileToggle && mainNav) {
        mobileToggle.addEventListener('click', function() {
            mainNav.classList.toggle('active');
        });
    }
});
</script>
<div class="menuMainDiv1">
<div class="menuMainDiv2">
<div class="tutorialSectionDiv1">
<a class="tutorialMainPageA1" href="/tutorials/kubernetes/">Kubernetes</a>
<span class="tutorialSectionTitleSeparatorSpan1">|</span>
<span class="tutorialSectionTitleSpan1">Kubernetes Secrets (secrets)</span>
<hr class="tutorialSectionHr1" />
<ol class="ol_decimal_contents_1">
<li><a href="#sec_id_1">Notes</a></li>
<li><a href="#sec_id_2">Kubernetes Secrets (secrets)</a></li>
<li><a href="#sec_id_3">Creating Secrets using kubectl</a><br >
    --from-literal<br >
    --from-file: from file without a key, from file with a key, from a directory<br >
    --from-env-file</li>
<li><a href="#sec_id_4">Creating Secrets using manifest YAML file</a></li>
<li><a href="#sec_id_5">Edit Secrets</a></li>
<li><a href="#sec_id_6">Using Secrets: Environment variables</a><br />
    env/valueFrom/secretKeyRef<br />
    envFrom/secretRef</li>
<li><a href="#sec_id_7">Using Secrets: Files in Volumes</a></li>
<li><a href="#sec_id_8">Referencing Secrets's environment variables in the container's command</a></li>
<li><a href="#sec_id_9">Delete Secrets</a></li>
</ol>
<hr class="tutorialSectionHr1" />
<ol class="ol_decimal_1">
<li id="sec_id_1">
<span class="tutorialSubSectionTitleSpan1">Notes</span>
<div class="tutorialSectionTextDiv1">
See these pages for more details about Secrets:<br />
<a href="https://kubernetes.io/docs/concepts/configuration/secret/">https://kubernetes.io/docs/concepts/configuration/secret/</a><br />
<a href="https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/">https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/</a><br />
<a href="https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/">https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/</a><br />
</div>
</li>
<li id="sec_id_2">
<span class="tutorialSubSectionTitleSpan1">Kubernetes Secrets (secrets)</span>
<div class="tutorialSectionTextDiv1">
Secrets allows creating data objects that can be consumed by Pods at runtime.<br />
<br />
Here's an example of a Secret (YAML):
<pre class="yaml-code">
apiVersion: v1
data:
  key1: dmFsdWUx
  key2: dmFsdWUy
kind: Secret
metadata:
  name: secretexample
type: Opaque</pre>
The manifest file of the Secret is pretty simple.
It contains the fields <b>apiVersion</b>, <b>kind</b>, and <b>metadata</b>.
It also contain the <b>data</b> field that contains the keys-values of the Secret.<br />
<br />
The data in Secrets is stored as key-value entries:<br />
<ul class="ul_square_1">
<li>
Key: is a string value formed by alphanumeric, dot (.), dash (-), and underscore (_) characters.<br />
<br /></li>
<li>
Value: is a base64-encoded string value.<br />
<br /></li>
</ul>
The key and the value, in the Secrets, are separated with a colon (<b>key:value</b>).<br />
<br />
The name of the Secrets must be a valid DNS subdomain name.<br />
<br />
The data stored in a Secrets can be consumed in a container in one the following ways:<br />
<ul class="ul_square_1">
<li>
Environment variables.<br />
<br /></li>
<li>
Command-line arguments of the container command.<br />
<br /></li>
<li>
Files in volumes.<br />
<br /></li>
<li>
Custom code (read the Secrets directly from the Kubernetes API).<br />
<br /></li>
</ul>
To encode a text into a base64 string:<br />
<pre class="sh-code">
$ echo -n 'value1' | base64</pre>
<pre class="sh-code">
dmFsdWUx</pre>
The -n flag ensures that the generated output doesn't have an extra newline character at the end of the text.
This is to avoid that the extra newline character gets encoded along with the text.<br />
<br />
To decode a base64 data:<br />
<pre class="sh-code">
$ echo 'dmFsdWUx' | base64 --decode</pre>
<pre class="sh-code">
value1</pre>
Note:
If you update a Secret that was already posted to the Kubernetes API server,
then Pods that were already created will be able to leverage the new data only if it was injected as files in a volume.
Secrets data injected as environment variables won't be updated in a running Pod unless you recreate it.<br />
</div>
</li>
<li id="sec_id_3">
<span class="tutorialSubSectionTitleSpan1">Creating Secrets using kubectl</span>
<div class="tutorialSectionTextDiv1">
The data of the Secrets can be specified using one of the following methods:<br />
<br />
<ul class="ul_square_1">
<li>
<b>generic --from-literal</b>:<br />
This command allows you to specify a key and literal value to insert in the Secret.<br />
<br />
You need to escape the special characters $, \, *, =, and ! (otherwise they will be interpreted by the shell).<br />
<br />
One way to escape the special characters is to enclose the value within single quotes (').<br />
<br />
Create the Secrets:<br />
<pre class="sh-code">
$ kubectl create secret generic secretfromliteral --from-literal="key1=value1" --from-literal=key2='value2'</pre>
<pre class="sh-code">
secret/secretfromliteral created</pre>
Check the Secret:<br />
<pre class="sh-code">
$ kubectl get secret secretfromliteral</pre>
<pre class="sh-code">
NAME                TYPE     DATA   AGE
secretfromliteral   Opaque   2      9m5s</pre>
Describe the Secret:<br />
<pre class="sh-code">
$ kubectl describe secret secretfromliteral</pre>
<pre class="sh-code">
Name:         secretfromliteral
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:  Opaque

Data
====
key1:  6 bytes
key2:  6 bytes</pre>
View the YAML file of the Secret:<br />
<pre class="sh-code">
$ kubectl get secrets secretfromliteral -o yaml</pre>
<pre class="yaml-code">
apiVersion: v1
data:
  key1: dmFsdWUx
  key2: dmFsdWUy
kind: Secret
metadata:
  name: secretfromliteral
type: Opaque</pre>
To decode the Secret of a specific key, you need to decode its base64 data:<br />
<pre class="sh-code">
$ kubectl get secrets secretfromliteral -o jsonpath='{.data.key1}' | base64 --decode -</pre>
<pre class="sh-code">
value1</pre>
<pre class="sh-code">
$ kubectl get secrets secretfromliteral -o jsonpath='{.data.key2}' | base64 --decode -</pre>
<pre class="sh-code">
value2</pre></li>
<li>
<b>generic --from-file</b>:<br />
This command allows you to specify a file path (<b>--from-file="./secrets/file1.txt"</b>), in which case the file base name will be used as the Secret key.<br />
<br />
Optionally you can use a key with the file path (<b>--from-file="mykey1=./secrets/file1.txt"</b>), in which case the given key will be used as the Secret key.<br />
<br />
If you specify a directory (<b>--from-file="./secrets/"</b>)
then kubectl will iterate each file in the directory and create a new entry for each file whose base name is a valid Secret key.<br />
<br />
The path to the file (or directory) can be an absolute path or relative to the location from where the "kubectl create secret" is executed.<br />
<br />
The content of the file can be anything.
You don't have to escape special characters in the text that you put in the file.<br />
<br />
Let's crate a directory to hold the Secrets data (this can be any location you want):<br />
<pre class="sh-code">
$ mkdir ./secrets/</pre>
Create a sample file "file1.txt" (single line text):<br />
<pre class="sh-code">
$ echo -n 'value1' > "./secrets/file1.txt"</pre>
Create a sample file "file2.txt" (multiple lines text):<br />
<pre class="sh-code">
$ echo 'value2-1' > "./secrets/file2.txt"
$ echo 'value2-2' >> "./secrets/file2.txt"</pre>
<ul class="ul_circle_1">
<li>
Create the Secret from a file without a key:<br />
<pre class="sh-code">
$ kubectl create secret generic secret1fromfile --from-file="./secrets/file1.txt" --from-file="./secrets/file2.txt"</pre>
<pre class="sh-code">
secret/secret1fromfile created</pre>
View the Secrets (notice that the content of the file is indented properly):<br />
<pre class="sh-code">
$ kubectl get secret secret1fromfile -o yaml</pre>
<pre class="yaml-code">
apiVersion: v1
data:
  file1.txt: dmFsdWUx # note that the name of the key is file1.txt
  file2.txt: dmFsdWUyLTEKdmFsdWUyLTIK # note that the name of the key is file2.txt
kind: Secret
metadata:
  name: secret1fromfile
type: Opaque</pre>
</li>
<li>
Create the Secret from a file with a key:<br />
<pre class="sh-code">
$ kubectl create secret generic secret2fromfile --from-file="mykey1=./secrets/file1.txt" --from-file="mykey2=./secrets/file2.txt"</pre>
<pre class="sh-code">
secret/secret2fromfile created</pre>
View the Secrets (notice that the content of the file is indented properly):<br />
<pre class="sh-code">
$ kubectl get secret secret2fromfile -o yaml</pre>
<pre class="yaml-code">
apiVersion: v1
data:
  mykey1: dmFsdWUx # note that the name of the key is mykey1
  mykey2: dmFsdWUyLTEKdmFsdWUyLTIK # note that the name of the key is mykey2
kind: Secret
metadata:
  name: secret2fromfile
type: Opaque</pre>
</li>
<li>
Create the Secret from a directory:<br />
<pre class="sh-code">
$ kubectl create secret generic secretfromdirectory --from-file="./secrets/"</pre>
<pre class="sh-code">
secret/secretfromdirectory created</pre>
View the Secrets (notice that the content of the file is indented properly):<br />
<pre class="sh-code">
$ kubectl get secret secretfromdirectory -o yaml</pre>
<pre class="yaml-code">
apiVersion: v1
data:
  file1.txt: dmFsdWUx # note that the name of the key is file1.txt
  file2.txt: dmFsdWUyLTEKdmFsdWUyLTIK # note that the name of the key is file2.txt
kind: Secret
metadata:
  name: secretfromdirectory
type: Opaque</pre>
</li>
</ul>
<br /></li>
<li>
<b>--from-env-file</b>:<br />
This command allows you to specify the path to an environement (properties) file (<b>--from-file="./secrets/file1.properties"</b>)
to read lines of <b>key=value</b> pairs to insert in the Secret.<br />
<br />
Create a sample property file:<br />
<pre class="sh-code">
$ vi "./secrets/file1.properties"</pre>
<pre class="sh-code">
key1=value1
key2=value2</pre>
Create the Secret:<br />
<pre class="sh-code">
$ kubectl create secret generic secretfromenvfile --from-env-file="./secrets/file1.properties"</pre>
<pre class="sh-code">
secret/secretfromenvfile created</pre>
View the Secret (notice that each entry in the property file is represented by a <b>key:value</b> pairs in the Secret):<br />
<pre class="sh-code">
$ kubectl get secret secretfromenvfile -o yaml</pre>
<pre class="yaml-code">
apiVersion: v1
data:
  key1: dmFsdWUx
  key2: dmFsdWUy
kind: Secret
metadata:
  name: secretfromenvfile
type: Opaque</pre>
</li>
</ul>
</div>
</li>
<li id="sec_id_4">
<span class="tutorialSubSectionTitleSpan1">Creating Secrets using manifest YAML file</span>
<div class="tutorialSectionTextDiv1">
The manifest YAML file defines Secrets with <b>key:value</b> entries.<br />
<br />
The values must be base64 encoded strings.<br />
<pre class="sh-code">
$ vi secretkeyvalue.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Secret
metadata:
  name: secretkeyvalue
data:
  key1: dmFsdWUx
  key2: dmFsdWUy</pre>
To apply the file:<br />
<pre class="sh-code">
$ kubectl apply -f secretkeyvalue.yaml</pre>
<pre class="sh-code">
secret/secretkeyvalue created</pre>
</div>
</li>
<li id="sec_id_5">
<span class="tutorialSubSectionTitleSpan1">Edit Secrets</span>
<div class="tutorialSectionTextDiv1">
If you have created a Secret using the manifest YAML file,
then to change that Secret you can adjust the YAML file and run the command <b>kubectl apply -f SECRET-YAML-FILE-PATH</b><br />
<br />
You can also use the command <b>kubectl edit secret SECRET-NAME</b> to edit a Secret.
The command will open the Secret in your default text editor.
Make your changes then save and exit the editor.
Your changes will be submitted to API Server.<br />
<br />
For example to view and edit the Secret "secretkeyvalue":<br />
<pre class="sh-code">
$ kubectl edit secret secretkeyvalue</pre>
<pre class="yaml-code">
# Please edit the object below.
# Lines beginning with a '#' will be ignored, and an empty file will abort the edit.
# If an error occurs while saving this file will be reopened with the relevant failures.
#
apiVersion: v1
data:
  key1: dmFsdWUx
  key2: dmFsdWUy
kind: Secret
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","data":{"key1":"dmFsdWUx","key2":"dmFsdWUy"},"kind":"Secret","metadata":{"annotations":{},"name":"secretkeyvalue"}}
  name: secretkeyvalue
type: Opaque</pre>
<pre class="sh-code">
secret/secretkeyvalue edited</pre>
</div>
</li>
<li id="sec_id_6">
<span class="tutorialSubSectionTitleSpan1">Using Secrets: Environment variables</span>
<div class="tutorialSectionTextDiv1">
In a Pod YAML file, You can reference the entries of the Secrets directly in the "spec.containers.<b>env</b>" field.
The environment variables will be set like any other standard Linux environment variables.
You can check them using the env command directly from inside the container.<br />
<br />
<ul class="ul_square_1">
<li>
env/valueFrom/secretKeyRef<br />
<br />
Let's use the Secret "secretkeyvalue" (see above) with the Pod "hello-busybox-secret-keyref":<br />
<pre class="sh-code">
$ vi hello-busybox-secret-keyref.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Pod
metadata:
  name: hello-busybox-secret-keyref
spec:
  containers:
    - name: hello-busybox-secret-keyref
      image: busybox:latest
      tty: true # (TeleTYpewriter) allocates a TTY / terminal console on the container
      stdin: true # Keeps stdin open on the container
      env:
        - name: mykey1
          valueFrom:
            secretKeyRef:
              name: secretkeyvalue
              key: key1
        - name: mykey2
          valueFrom:
            secretKeyRef:
              name: secretkeyvalue
              key: key2</pre>
Note:
You can give the environment variable a different name than the Secrets key name (i.e. name: mykey1).<br />
<br />
Apply the Pod:<br />
<pre class="sh-code">
$ kubectl apply -f hello-busybox-secret-keyref.yaml</pre>
<pre class="sh-code">
pod/hello-busybox-secret-keyref created</pre>
Check the environment variables:<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-keyref -- env | grep key</pre>
<pre class="sh-code">
mykey1=value1
mykey2=value2</pre>
Note that the secrets are clear text!<br />
<br /></li>
<li>
envFrom/secretRef<br />
<br />
Instead of referencing individual entries of the Secret,
you can use the "spec.containers.<b>envFrom</b>" field to reference all entries of the Secret:<br />
<pre class="sh-code">
$ vi hello-busybox-secret-ref.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Pod
metadata:
  name: hello-busybox-secret-ref
spec:
  containers:
    - name: hello-busybox-secret-ref
      image: busybox:latest
      tty: true
      stdin: true
      envFrom:
        - secretRef:
            name: secretkeyvalue</pre>
Apply the Pod:<br />
<pre class="sh-code">
$ kubectl apply -f hello-busybox-secret-ref.yaml</pre>
<pre class="sh-code">
pod/hello-busybox-secret-ref created</pre>
Check the environment variables:<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-ref -- env | grep key</pre>
<pre class="sh-code">
key1=value1
key2=value2</pre>
</li>
</ul>
</div>
</li>
<li id="sec_id_7">
<span class="tutorialSubSectionTitleSpan1">Using Secrets: Files in Volumes</span>
<div class="tutorialSectionTextDiv1">
Secrets can also be referenced using volumes.<br />
<br />
Each entry of the Secrets will be referenced as a separate file in the volume.<br />
<br />
The changes to the Secrets will be reflect directly in the volumes.<br />
<br />
The Secrets is defined as a volume (spec.volumes) and mounted to the container (spec.containers.volumeMounts).<br />
<br />
<ul class="ul_square_1">
<li>
In the following example, the "spec.<b>volumes</b>" field creates a volume (named secretkeyvalue) from the "secretkeyvalue" Secrets.<br />
The "spec.containers.<b>volumeMounts</b>" field mounts the volume (secretkeyvalue) into the container (under /tmp/secretkeyvalue).<br />
The volume will be populated with files where the file name is the key of the Secrets (key1, key2) and the content of the file is the value of the key (value1, value2).<br />
<pre class="sh-code">
$ vi hello-busybox-secret-volume.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Pod
metadata:
  name: hello-busybox-secret-volume
spec:
  containers:
    - name: hello-busybox-secret-volume
      image: busybox:latest
      tty: true
      stdin: true
      volumeMounts:
        - name: secretkeyvalue
          mountPath: /tmp/secretkeyvalue
  volumes:
    - name: secretkeyvalue
      secret:
        secretName: secretkeyvalue</pre>
Apply the Pod:<br />
<pre class="sh-code">
$ kubectl apply -f hello-busybox-secret-volume.yaml</pre>
<pre class="sh-code">
pod/hello-busybox-secret-volume created</pre>
Check the files in the volume (notice two files are created: key1, key2):<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-volume -- ls -l /tmp/secretkeyvalue</pre>
<pre class="sh-code">
lrwxrwxrwx    1    root    root    key1 -> ..data/key1
lrwxrwxrwx    1    root    root    key2 -> ..data/key2</pre>
Check the content of the files:<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-volume -- cat /tmp/secretkeyvalue/key1</pre>
<pre class="sh-code">
value1</pre>
</li>
<li>
You can also decide what entries of the Secret can be mounted.<br />
<br />
You can also decide the names of the files in the volume "<b>path</b>".<br />
<pre class="sh-code">
$ vi hello-busybox-secret-volume-item.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Pod
metadata:
  name: hello-busybox-secret-volume-item
spec:
  containers:
    - name: hello-busybox-secret-volume-item
      image: busybox:latest
      tty: true
      stdin: true
      volumeMounts:
        - name: secretkeyvalue
          mountPath: /tmp/secretkeyvalue
  volumes:
    - name: secretkeyvalue
      secret:
        secretName: secretkeyvalue
        items:
          - key: key1
            path: key1path</pre>
Apply the Pod:<br />
<pre class="sh-code">
$ kubectl apply -f hello-busybox-secret-volume-item.yaml</pre>
<pre class="sh-code">
pod/ello-busybox-secret-volume-item created</pre>
Check the files in the volume (notice the "key1path" file was created):<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-volume-item -- ls -l /tmp/secretkeyvalue</pre>
<pre class="sh-code">
lrwxrwxrwx    1    root    root    key1path -> ..data/key1path</pre>
Check the content of the files:<br />
<pre class="sh-code">
$ kubectl exec hello-busybox-secret-volume-item -- cat /tmp/secretkeyvalue/key1path</pre>
<pre class="sh-code">
value1</pre>
</li>
</ul>
</div>
</li>
<li id="sec_id_8">
<span class="tutorialSubSectionTitleSpan1">Referencing Secrets' environment variables in the container's command</span>
<div class="tutorialSectionTextDiv1">
You can use the data of the Secret to set the arguments of the container command.<br />
<br />
You need to use the following syntax to reference the environment variable: <b>$(ENV_VAR_NAME)</b>.<br />
<br />
As previously mentioned, changes to the Secret won't be reflected on the environment variables already set.<br />
<pre class="sh-code">
$ vi hello-busybox-secret-keyref-arg.yaml</pre>
<pre class="yaml-code">
apiVersion: v1
kind: Pod
metadata:
  name: hello-busybox-secret-keyref-arg
spec:
  containers:
    - name: hello-busybox-secret-keyref-arg
      image: busybox:latest
      command: ['sh', '-c', 'echo "mykey1:$(mykey1) | mykey2:$(mykey2)"; sleep 300;']
      env:
        - name: mykey1
          valueFrom:
            secretKeyRef:
              name: secretkeyvalue
              key: key1
        - name: mykey2
          valueFrom:
            secretKeyRef:
              name: secretkeyvalue
              key: key2</pre>
Apply the Pod:<br />
<pre class="sh-code">
$ kubectl apply -f hello-busybox-secret-keyref-arg.yaml</pre>
<pre class="sh-code">
pod/hello-busybox-secret-keyref-arg created</pre>
Check the logs of the Pod:<br />
<pre class="sh-code">
$ kubectl logs hello-busybox-secret-keyref-arg</pre>
<pre class="sh-code">
mykey1:value1 | mykey2:value2</pre>
</div>
</li>
<li id="sec_id_9">
<span class="tutorialSubSectionTitleSpan1">Delete Secrets</span>
<div class="tutorialSectionTextDiv1">
To delete a Secret: using manifest file (<b>kubectl delete</b>):<br />
<pre class="sh-code">
$ kubectl delete -f secretkeyvalue.yaml</pre>
<pre class="sh-code">
secret "secretkeyvalue" deleted</pre>
To delete a Secret using its name:<br />
<pre class="sh-code">
$ kubectl delete secret secretkeyvalue</pre>
<pre class="sh-code">
secret "secretkeyvalue" deleted</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="menuFooterDiv1">
<div class="container">
<div class="footer-content">
<div class="copyright">
<a href="/" class="footer-logo">
<span class="logo-mti">mti</span><span class="logo-tek">tek</span>
</a>
</div>
</div>
</div>
</div>
</div>
</body>
</html>